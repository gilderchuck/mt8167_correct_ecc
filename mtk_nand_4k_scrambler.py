#!/usr/bin/env python3
"""
(De)scramble (randomize) raw NAND dumps generated by Mediatek MT8167/MT8516 SoCs

Works on 4096+256B size pages only; drops any leftover bytes after the last full page.

Outputs a (de)scrambled bitstream including the spare (OOB) area of the pages.
(The bitstream can still contain bitflips, so might need ECC correction.)

This command can be used in a unix pipeline - it falls back automagically
to using stdin & stdout.

Having NumPy installed is recommended for a huge performance boost.

For updates please check https://github.com/gilderchuck/mtk-nand-utils

SPDX-License-Identifier: AGPL-3.0-or-later
V0.1 Copyright (C) 2025 Gilderchuck
"""

import argparse
import sys

try:
    from numpy import bitwise_xor
except ImportError:
    # fall back to a minimal, slow implementation
    def bitwise_xor(one, two):
        return [a ^ b for (a, b) in zip(one, two)]


args = {}


# make command pipeline-friendly by printing all messages to stderr
def eprint(*args, **kwargs):
    kwargs['file'] = sys.stderr
    print(*args, **kwargs)


# LFSR polynomial: x^120 + x^8 + 1
# Note: taps are on byte boundaries, which makes it possible
# to calculate whole bytes in each step.
# Instead of bitshifts we'll use a circular buffer and move the tail pointer only.
# Loosely based on the Fibonacci algorithm.
def gen_lfsr_cycle(seed):
    if len(seed) < 15:
        sys.exit("ERROR: LFSR seed too short")
    state = bytearray(seed[0:15])
    tail = 0
    result = bytearray()
    # Sequence repeats after 32767 bytes.
    # Let it run for longer by one chunk's length in order to
    # avoid handling the wrap-around later in the code.
    for _ in range(32767+1087):
        # the 8 bits to be shifted out of state, also used as X^0
        output = state[tail]
        # previous tail becomes the new front
        front = tail
        # advance tail for the next iteration
        tail = (tail + 1) % 15
        # array of X^8s is at the following byte
        feedback = output ^ state[tail]
        # put feedback bits to the front of the state, X^120
        state[front] = feedback
        result.append(output)
    return result


def build_xor_map():
    # byte offsets for PRBS-15 seeds 0x576A, 0x05E8, 0x629D, ...
    lfsr_offsets = [
        0,      5693, 28321, 29030,  1711, 28882, 14856, 17359,
        29737, 14491, 23235,  3360, 27462,  6838,  5487, 28646,
        18160,  9441, 15475, 23624, 14445,  1675, 23915,  2149,
        3519,  31403, 20014,  2519, 29862, 23465, 32357, 23505,
        19582, 30006, 16819, 27825, 22778,  8483, 23298,  7454,
        2617,   5488,  6929,  1474,  2840, 29204,  6948, 21183,
        8533,  20129, 23094, 31319, 29802, 32271, 22599, 26911,
        7750,  16472, 29901, 29367, 30245, 16631, 23635,  3500,
    ]

    # 15 consecutive bytes are required as a seed for a 120 bit LFSR,
    # for seed 0x576A PRBS-15 generates these initial ones:
    lfsr_lookup = gen_lfsr_cycle([0xCF, 0x7E, 0xD4, 0x20, 0x5F, 0x58, 0x38, 0x3A,
                                  0x92, 0x93, 0x2D, 0xAD, 0xDD, 0xBD, 0x99])
    xor_map = []

    for offs in lfsr_offsets:
        chunk = bytearray(lfsr_lookup[offs:offs+1088])
        # 4 chunks (subpages/partial pages) of a page use the same mask.
        # (We trade ~205KiB of extra memory here for
        # not having to deal with chunks individually later.)
        chunk.extend(chunk)
        chunk.extend(chunk)
        xor_map.append(chunk)
    return xor_map


def scramble(pagenum, raw_page, xor_map):
    return bytearray(bitwise_xor(raw_page, xor_map[pagenum % 64]))


def process_args():
    global args
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-o", "--output", dest="outfile",
        help="file to write (de)scrambled pages into")
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="verbose output")
    parser.add_argument(
        "infile", nargs="?",
        help="raw NAND dump with (de)scrambled data")
    args = parser.parse_args()

    # do not expect an input filename if part of a unix pipeline
    if args.infile is None and not sys.stdin.isatty():
        args.fi = sys.stdin.buffer
    elif args.infile is None:
        eprint(f"ERROR: no input file specified")
        parser.print_usage(file=sys.stderr)
        sys.exit(1)
    elif args.infile == "-":
        args.fi = sys.stdin.buffer
    else:
        try:
            args.fi = open(args.infile, "rb")
        except IOError as e:
            sys.exit(f"ERROR: unable to open input file ({e.errno}): "
                     f"{e.strerror}")

    # do not expect an output filename if part of a unix pipeline
    if args.outfile is None and not sys.stdout.isatty():
        args.fo = sys.stdout.buffer
    elif args.outfile is None:
        eprint(f"ERROR: no output file specified")
        parser.print_usage(file=sys.stderr)
        sys.exit(1)
    elif args.outfile == "-":
        args.fo = sys.stdout.buffer
    else:
        try:
            args.fo = open(args.outfile, "wb")
        except IOError as e:
            sys.exit(f"ERROR: unable to open output file ({e.errno}): "
                     f"{e.strerror}")


def main():
    process_args()

    xor_map = build_xor_map()

    pagenum = 0
    empty = b'\xFF' * 4352

    while True:
        page = bytearray(args.fi.read(4352))

        if len(page) != 4352:
            break

        if page == empty:
            if args.verbose:
                eprint(f"INFO: page {pagenum} empty")
        else:
            page = scramble(pagenum, page, xor_map)

        try:
            args.fo.write(page)
        except BrokenPipeError:
            break
        pagenum += 1

    args.fo.close()
    args.fi.close()


if __name__ == "__main__":
    main()
